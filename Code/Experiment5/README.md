# Experiment 5: 多机可靠传输实验

本目录包含实验五的代码实现，基于实验四的路由功能，增加了运输层可靠传输机制。

## 实验目标

1. **基于实验四的网络层功能**：实现任意两台 PC 间的数据交付（使用 DV 动态路由）
2. **实现运输层可靠传输机制**：采用**停等协议**（Stop-and-Wait）
3. **数据完整性校验**：使用 CRC32 校验码检测错误
4. **超时重传机制**：当接收方没有在规定时间内回复 ACK，发送方会自动重传
5. **错误模拟与验证**：通过手动模拟校验错误和丢包，验证可靠传输的有效性

## 协议设计

### 网络层（基于实验四）
- **类型**：HELLO（邻居发现）、DV（路由交换）、DATA（数据转发）
- **转发机制**：基于 Distance Vector 算法的动态路由

### 运输层（新增）

**数据帧格式**：
```
SrcPort | DstPort | Seq | Checksum | Type | Body
```

**包类型**：
- `SYN`: 启动新会话，同步初始序列号
- `SYN-ACK`: 确认会话建立
- `DAT`: 普通数据包
- `ACK`: 数据确认

**工作流程**：
1. **建立会话（3步握手简化版）**
   - 发送方：发送 SYN (包含数据)
   - 接收方：收到 SYN → 检查校验码 → 回复 SYN-ACK
   - 发送方：收到 SYN-ACK → 数据交付完成

2. **校验与重传**
   - 接收端对每个包计算 CRC32 校验码
   - 校验失败 → 丢弃，不回复 ACK（发送方超时重传）
   - 校验成功 → 回复 ACK，交付应用层

3. **超时检测**
   - 发送方设置 3 秒超时
   - 超时未收到 ACK → 重传（最多 3 次）
   - 3 次都失败 → 放弃发送

## 文件说明

- `reliable_router.py`: 主程序，集成了以下功能：
  - 串口通信管理
  - 邻居发现和路由更新（实验四）
  - 运输层数据封装/解封装（实验五）
  - CRC32 校验
  - 停等协议实现
  - 故障模拟

## 运行方式

### 1. 环境准备
确保已安装 `pyserial` 库：
```shell
pip install pyserial
```

### 2. 启动程序
在每一台参与实验的计算机上运行：
```shell
python Code/Experiment5/reliable_router.py
```

### 3. 操作流程

#### 第一步：启动网络
```
请输入本机ID (例如 A, B, PC1): A
请选择要激活的串口: all
```
等待约 10-15 秒，系统会自动发现邻居并构建路由表。

#### 第二步：查看路由表
```
> table
============================================================
当前路由表 (Distance Vector)
============================================================
目标         开销         下一跳       接口              
A          0          A          LOCAL          
B          1          B          COM3           
C          2          B          COM3           
============================================================
```

#### 第三步：发送可靠消息
```
> send B "Hello from A"
=== 开始可靠发送到 B ===
[TX] 发送 SYN (Seq=12345, 数据='Hello from A')
[TX] SYN已发送 (尝试 1/3)... 等待SYN-ACK
[RX ACK] 确认成功，停止重传
=== 发送成功 ===
```

## 命令参考

| 命令 | 说明 | 示例 |
|------|------|------|
| `table` / `t` | 显示路由表 | `> table` |
| `send <ID> <MSG>` | 向目标发送可靠消息 | `> send B "Hello"` |
| `corrupt on/off` | 开启/关闭校验码篡改模拟 | `> corrupt on` |
| `loss on/off` | 开启/关闭丢包模拟 | `> loss on` |
| `help` / `h` / `?` | 显示帮助信息 | `> help` |
| `exit` / `quit` | 退出程序 | `> exit` |

## 实验场景

### 场景 1：正常通信
```
> send B "Test message 1"
=== 开始可靠发送到 B ===
[TX] 发送 SYN (Seq=54321, 数据='Test message 1')
[TX] SYN已发送 (尝试 1/3)... 等待SYN-ACK
[TX] 收到 SYN-ACK，会话已建立
=== 发送成功 ===
```

### 场景 2：模拟校验错误（接收端丢弃 → 发送端超时重传）
```
> corrupt on
> send B "Error test"
=== 开始可靠发送到 B ===
[TX] 发送 SYN (Seq=33333, 数据='Error test')
[Simulate] 模拟校验码错误 (SYN包校验码将损坏)
[TX] SYN已发送 (尝试 1/3)... 等待SYN-ACK
[RX Error] 校验失败! 来自A Seq=33333 (Recv:123456 vs Calc:654321) - 丢弃
[TX] SYN超时，准备重传...
[TX] SYN已发送 (尝试 2/3)... 等待SYN-ACK
[TX] 收到 SYN-ACK，会话已建立
=== 发送成功 ===
```
**说明**：第一个包因为校验码错误被丢弃，第二次重传成功。

### 场景 3：模拟丢包（网络层丢弃 → 发送端超时重传）
```
> loss on
> send B "Loss test"
=== 开始可靠发送到 B ===
[TX] 发送 SYN (Seq=22222, 数据='Loss test')
[Simulate] 模拟丢包 (本应发往 COM3)
[TX] SYN已发送 (尝试 1/3)... 等待SYN-ACK
[TX] SYN超时，准备重传...
[TX] SYN已发送 (尝试 2/3)... 等待SYN-ACK
[TX] 收到 SYN-ACK，会话已建立
=== 发送成功 ===
```
**说明**：第一个包被网络丢失，第二次重传后成功。

### 场景 4：多跳转发
在 A、B、C 三台 PC 的网络中：
```
PC-A > send C "Message to C"
```
A 会通过 B 转发给 C，整个过程仍保证可靠传输。

## 核心实现细节

### 1. CRC32 校验
```python
def _calculate_checksum(self, src, dst, seq, t_type, body):
    content = f"{src}{SEPARATOR}{dst}{SEPARATOR}{seq}{SEPARATOR}{t_type}{SEPARATOR}{body}"
    return zlib.crc32(content.encode('utf-8')) & 0xffffffff
```

### 2. 停等协议
- **发送端**：发送一个包后必须等待 ACK，否则超时后重传
- **接收端**：收到正确的包立即回复 ACK，错误的包不回复（触发超时重传）
- **优点**：实现简单，易于验证
- **缺点**：效率低（停等期间无法发送其他数据）

### 3. 序列号机制
- 每次发送使用随机初始序列号（类似 TCP ISN）
- 接收端维护期望的下一个序列号
- 用于检测重复和失序包

### 4. 超时参数
- **TIMEOUT_RETRANSMIT**: 3 秒（等待 ACK 的超时时间）
- **MAX_RETRIES**: 3 次（最大重传次数）

## 测试建议

1. **基础测试**：在两台 PC 间正常通信 3-5 次
2. **校验测试**：开启 `corrupt` 模拟，观察重传行为
3. **丢包测试**：开启 `loss` 模拟，观察重传行为
4. **多跳测试**：在三台或更多 PC 的网络中通信
5. **路由变动**：断开某条链路，观察路由自动调整

## 常见问题

**Q: 为什么发送后没有立即显示"发送成功"？**  
A: 停等协议会等待 3 秒来接收 ACK，这是设计的行为。请确保目标节点正在运行。

**Q: 如何关闭错误模拟？**  
A: 使用命令 `corrupt off` 或 `loss off`。

**Q: 为什么某些目标发送失败？**  
A: 可能原因：
- 目标节点未启动
- 网络不连通（检查路由表）
- 路由表未收敛（等待约 15 秒）

**Q: 校验码每次都不同，为什么？**  
A: CRC32 基于完整的帧内容计算，序列号和数据不同，校验码也会不同。这是正确的行为。
